[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/87ylncIN)
# Лабораторная работа 2: In-memory кэш 

## Цель работы
Научиться применять функции высшего порядка, а также освоить ключевые концепции для создания гибкого и типизированного кода.
Студенты закрепят навыки:
- Передачи функций как аргументов
- Создания и использования анонимных функций и замыканий
- Реализации операций `map`, `filter` и `reduce` в Go
- Работы с интерфейсами и их реализацией
- Использования пустых интерфейсов и type assertion
- Применения композиции
- Использования дженериков для универсальных решений


## Задание
- Реализовать систему кэширования с поддержкой различных стратегий управления данными
- Реализовать различные декораторы, полезные при работе с кэшом: декоратор для сбора метрик, декораторы, реализующие поведение чистых функций (`map`, `filter`, `reduce`) и т.д. При реализации декораторов можно использовать новые интерфейсы.

## Формулировка
Дан базовый интерфейс кэша:
```
type Cache[K comparable, V any] interface {
    Get(key K) (V, error)
    Set(key K, value V) error
    Delete(key K) error
    Clear()
}
```

###  Стратегии

На основе этого интерфейса требуется реализовать следующие стратегии:
1. **FIFO (First-In-First-Out) кэш**

Пример того, как это может выглядеть: 

```
    type lruCache[K comparable, V any] struct {
        capacity  int
        cache     map[K]*list.Element
        evictList *list.List
    }

    func NewLRUCache[K comparable, V any](capacity int) Cache[K, V] {
        return &lruCache[K, V]{
            capacity:  capacity,
            cache:     make(map[K]*list.Element),
            evictList: list.New(),
        }
    }
```

2. **LRU (Least Recently Used) кэш**

3. **LFU (Least Frequently Used) кэш**

4. **Кэш с поддержкой TTL (Time-To-Live). Автоматическое удаление по истечении времени жизни**

5. **Adaptive replacement cache стратегия**

Важное замечание: защиты от конкурентного доступа не подразумевается, поэтому использовать примитивы синхронизации не требуется.

### Декораторы

Часто при работе с кешами хочется иметь полезные утилиты-надстройки, которые, например, добавят observability функциональность (вроде метрик и дополнительных логов). Распространенная практика в таких случаях - реализовывать такую функциональность через декораторы.

1. Декоратор **WithMetrics**. Он позволит получать основные метрики, полезные при работе с кешами: hit/miss rate, метрика заполненности кэша, key evictions и тд. Для вдохновения можно использовать redis как основу для всевозможных метрик.
Пример того, как это может выглядеть:

```
type statsCache[K comparable, V any] struct {
	cache       Cache[K, V]
	hits        int
	misses      int
	evictions   int
}

func WithMetrics[K comparable, V any](cache Cache[K, V]) Cache[K, V] {
	return &statsCache[K, V]{
		cache: cache,
	}
}
```

2. Декоратор для сжатия данных **WithCompression**. Здесь ключевыми будут факты сериализации и десериализации, можно взять любой комфортный формат - json, gob и тд. Подумать, можно ли как-то получить метрику сжатия данных для декоратора выше. 

3. Декоратор для быстрой проверки отсутствия ключа на основе Bloom Filter **WithBloomFilter**.

4. Декоратор для DEBUG логирования **WithDebugLogging**. Тут можно добавить debug логи до или после каждой операции над кэшом.


Как может выглядеть комбинирование декоратора и кэша:

```
func main() {
    // Кэш с стратегией LRU и блум-фильтром
    cache := WithBloomFilter(
        LRUCache[string, User](100),
        1000, // capacity битового массива
        func(key string) []byte { return []byte(key) }, //хэш фукнция
    )

    // Универсальный кэш с TTL
    anyCache := TTLCache[string, interface{}](time.Hour)
    anyCache.Set("config", map[string]int{"timeout": 30})
}
```

### Декораторы функционального программирования

Тут предстоит реализовать декораторы, которые реализуют чистые функции `map`, `filter`, `reduce` вокруг кэша.

1. Декоратор `map`: принимает экземпляр кэша, функцию и применяет функцию ко всем значениям в исходном кэше. Важно: исходной кэш не должен быть видоизменен, `map` должен создать новый экземпляр кэша. Каким-либо образом мутировать исходный кэш запрещено. Аналогия из [haskell](https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:map).

2. Декоратор `filter`: принимает экземпляр кэша, функцию c результирующим типом `bool` и отфильтровывает значения в исходном кэше. Как и в случае с `map`, `filter` не должен мутировать исходный кэш, а создать новый экземпляр.  

3. Декоратор `reduce`: должен возвращать аггрегат на основе все значений в кэше. 

```

type ReduceCache[K comparable, V any, R any] struct {
	parent   Cache[K, V]
	reduceFn func(R, V) R
	initial  R
}

// WithReduce создает декоратор для агрегации значений
// Возвращает единый результат после применения reduceFn ко всем значениям
func WithReduce[K comparable, V any, R any](
	cache Cache[K, V],
	initial R,
	reduceFn func(acc R, value V) R,
) R 
```

Важно, чтобы декораторы можно было композировать друг с другом, например:

```
cache := WithMetrics(
    WithFilter(
        WithMap(baseCache, mapperFn),
        filterFn),
)
```

### Нефункциональные требования

1. Примерная структура

```
cache-lab/
├── internal/
│   ├── cache/
│   │   ├── interfaces.go         # Основные интерфейсы (Cache)
│   │   ├── strategies/
│   │   │   ├── lru.go           # LRU реализация
│   │   │   ├── lru_test.go      # LRU реализация
│   │   │   ├── fifo.go          # FIFO реализация
│   │   │   ├── fifo_test.go     # FIFO реализация  
│   │   │   ├── arc.go           # ARC реализация
│   │   │   └── ttl.go           # TTL реализация
│   │   ├── decorators/
│   │   │   ├── filter.go        # Filter декоратор
│   │   │   ├── map.go           # Map декоратор
│   │   │   └── reduce.go        # Reduce декоратор
│   │   ├── builder.go           # Фабрика для создания кэшей
├── examples/
│   ├── simple_cache/            # Базовое использование
│   │   └── main.go
├── go.mod                       # Зависимости
└── README.md                    # Инструкции + документация
```

2. Должны быть написаны тесты на каждую реализованную стратегию или декоратор. Test coverage > 50%. Файлы с тестами должны лежать рядом с основной функциональностью (см примерную структуру). 

3. В examples должны быть базовые примеры использования 

4. В README.md должно быть описано то, как можно запустить тесты, примеры, и как можно проверить coverage. А также краткое описание того, что реализовано. 

## Оцениваемые разделы

- Функции высшего порядка в Go: функциональные походы на практике
    - Функции как объекты первого класса
    - Анонимные функции и замыкания
    - Реализация `map`, `filter`, `reduce` в Go
    - Применение функций высшего порядка в бизнес-логике

- Пустые интерфейсы, type assertion и дженерики: универсальные подходы в Go
    - Разница между наследованием и композицией 
    - Использование Generics
    - Пустые интерфейсы и type assertions

## Как производится оценка

1. Стратегии FIFO, LRU, LFU, TTL, декоратор WithMetrics - 6 баллов
2. Adaptive replacement cache стратегия - 1 балл
3. Декораторы WithCompression, WithBloomFilter и WithDebugLogging - 1 балл
4. Декораторы функционального программирования - 1 балл
5. Наличие примеров использования, написанная README.md и удовлетворительный coverage - 1 балл
