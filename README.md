## Цель работы
Научиться применять функции высшего порядка, а также освоить ключевые концепции для создания гибкого и типизированного кода.
Студенты закрепят навыки:
- Передачи функций как аргументов
- Создания и использования анонимных функций и замыканий
- Реализации операций `map`, `filter` и `reduce` в Go
- Работы с интерфейсами и их реализацией
- Использования пустых интерфейсов и type assertion

5. **Adaptive replacement cache стратегия**

Важное замечание: защиты от конкурентного доступа не подразумевается, поэтому использовать примитивы синхронизации не требуется.

### Декораторы

3. Декоратор для быстрой проверки отсутствия ключа на основе Bloom Filter **WithBloomFilter**.


Как может выглядеть комбинирование декоратора и кэша:


### Декораторы функционального программирования

Тут предстоит реализовать декораторы, которые реализуют чистые функции `map`, `filter`, `reduce` вокруг кэша.

1. Декоратор `map`: принимает экземпляр кэша, функцию и применяет функцию ко всем значениям в исходном кэше. Важно: исходной кэш не должен быть видоизменен, `map` должен создать новый экземпляр кэша. Каким-либо образом мутировать исходный кэш запрещено. Аналогия из [haskell](https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:map).

2. Декоратор `filter`: принимает экземпляр кэша, функцию c результирующим типом `bool` и отфильтровывает значения в исходном кэше. Как и в случае с `map`, `filter` не должен мутировать исходный кэш, а создать новый экземпляр.  

3. Декоратор `reduce`: должен возвращать аггрегат на основе все значений в кэше. 

```

type ReduceCache[K comparable, V any, R any] struct {
	parent   Cache[K, V]
	reduceFn func(R, V) R
	initial  R
}

// WithReduce создает декоратор для агрегации значений
// Возвращает единый результат после применения reduceFn ко всем значениям
func WithReduce[K comparable, V any, R any](
	cache Cache[K, V],
	initial R,
	reduceFn func(acc R, value V) R,
) R 
```

Важно, чтобы декораторы можно было композировать друг с другом, например:

```
cache := WithMetrics(
    WithFilter(
        WithMap(baseCache, mapperFn),
        filterFn),
)
```

### Нефункциональные требования

2. Должны быть написаны тесты на каждую реализованную стратегию или декоратор. Test coverage > 50%. 

3. В examples должны быть базовые примеры использования 

4. В README.md должно быть описано то, как можно запустить тесты, примеры, и как можно проверить coverage. А также краткое описание того, что реализовано. 

## Оцениваемые разделы

- Функции высшего порядка в Go: функциональные походы на практике
    - Функции как объекты первого класса
    - Анонимные функции и замыкания
    - Реализация `map`, `filter`, `reduce` в Go
    - Применение функций высшего порядка в бизнес-логике

- Пустые интерфейсы, type assertion и дженерики: универсальные подходы в Go
    - Разница между наследованием и композицией 
    - Использование Generics
    - Пустые интерфейсы и type assertions

## Как производится оценка

1. Стратегии FIFO, LRU, LFU, TTL, декоратор WithMetrics - 6 баллов
2. Adaptive replacement cache стратегия - 1 балл
3. Декораторы WithCompression, WithBloomFilter и WithDebugLogging - 1 балл
4. Декораторы функционального программирования - 1 балл
5. Наличие примеров использования, написанная README.md и удовлетворительный coverage - 1 балл
